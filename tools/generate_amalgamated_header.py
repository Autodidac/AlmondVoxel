#!/usr/bin/env python3
"""Generate a single-header amalgamation of the AlmondVoxel public API."""

from __future__ import annotations

import argparse
import re
from pathlib import Path
from typing import Dict, Iterable, List, Set

INCLUDE_PATTERN = re.compile(r"^\s*#\s*include\s*\"([^\"]+)\"", re.MULTILINE)


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Generate an amalgamated header by topologically sorting AlmondVoxel's "
            "public headers."
        )
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=None,
        help=(
            "Location where the amalgamated header should be written. If omitted, "
            "the file is placed at include/almond_voxel_single.hpp relative to the "
            "project root."
        ),
    )
    parser.add_argument(
        "--guard",
        default="ALMOND_VOXEL_SINGLE_HPP",
        help="Override the include guard identifier used in the generated header.",
    )
    return parser.parse_args()


def collect_headers(include_root: Path) -> List[Path]:
    headers = sorted(include_root.rglob("*.hpp"))
    if not headers:
        raise RuntimeError(f"No headers found under {include_root}")
    return headers


def build_dependency_graph(headers: Iterable[Path], include_root: Path) -> Dict[Path, Set[Path]]:
    graph: Dict[Path, Set[Path]] = {header.resolve(): set() for header in headers}

    for header in headers:
        content = header.read_text(encoding="utf-8")
        for include_target in INCLUDE_PATTERN.findall(content):
            if not include_target.startswith("almond_voxel/"):
                continue
            relative_target = include_target[len("almond_voxel/") :]
            candidate = (include_root / relative_target).resolve()
            if candidate in graph:
                graph[header.resolve()].add(candidate)
    return graph


def topological_sort(graph: Dict[Path, Set[Path]]) -> List[Path]:
    order: List[Path] = []
    temporary: Set[Path] = set()
    permanent: Set[Path] = set()

    def visit(node: Path) -> None:
        if node in permanent:
            return
        if node in temporary:
            cycle = " -> ".join(str(p) for p in list(temporary) + [node])
            raise RuntimeError(
                f"Cycle detected while generating amalgamated header: {cycle}"
            )
        temporary.add(node)
        for neighbour in sorted(graph[node]):
            visit(neighbour)
        temporary.remove(node)
        permanent.add(node)
        order.append(node)

    for node in sorted(graph):
        visit(node)

    return order


def strip_internal_includes(content: str) -> str:
    lines = []
    for line in content.splitlines():
        stripped = line.strip()
        if stripped.startswith("#pragma once"):
            continue
        match = INCLUDE_PATTERN.match(line)
        if match and match.group(1).startswith("almond_voxel/"):
            continue
        lines.append(line)
    return "\n".join(lines)


def generate_header(order: List[Path], include_root: Path, guard: str) -> str:
    project_root = include_root.parent
    rel_paths = {path: path.relative_to(project_root) for path in order}

    chunks = []
    header_notice = (
        "// This file is auto-generated by tools/generate_amalgamated_header.py.\n"
        "// Do not edit this file manually; instead, edit the source headers and\n"
        "// re-run the generator.\n\n"
    )
    chunks.append(header_notice)
    chunks.append(f"#ifndef {guard}\n#define {guard}\n\n")

    for path in order:
        if path.name == "almond_voxel.hpp":
            continue
        rel_path = rel_paths[path]
        chunks.append(f"// begin: {rel_path.as_posix()}\n")
        content = path.read_text(encoding="utf-8")
        content = strip_internal_includes(content)
        if content:
            chunks.append(content)
            if not content.endswith("\n"):
                chunks.append("\n")
        chunks.append(f"// end: {rel_path.as_posix()}\n\n")

    chunks.append(f"#endif // {guard}\n")
    return "".join(chunks)


def main() -> None:
    args = parse_arguments()
    script_path = Path(__file__).resolve()
    project_root = script_path.parent.parent
    include_root = project_root / "include" / "almond_voxel"

    headers = collect_headers(include_root)
    graph = build_dependency_graph(headers, include_root)
    order = topological_sort(graph)

    output_path = args.output
    if output_path is None:
        output_path = project_root / "include" / "almond_voxel_single.hpp"
    else:
        output_path = output_path.resolve()

    output_path.parent.mkdir(parents=True, exist_ok=True)
    content = generate_header(order, include_root, args.guard)
    output_path.write_text(content, encoding="utf-8")

    print(f"Generated amalgamated header at {output_path}")


if __name__ == "__main__":
    main()
