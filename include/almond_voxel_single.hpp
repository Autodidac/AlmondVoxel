// This file is auto-generated by tools/generate_amalgamated_header.py.
// Do not edit this file manually; instead, edit the source headers and
// re-run the generator.

#ifndef ALMOND_VOXEL_SINGLE_HPP
#define ALMOND_VOXEL_SINGLE_HPP

// begin: almond_voxel/core.hpp

#include <array>
#include <cstddef>
#include <cstdint>
#include <span>
#include <string_view>
#include <type_traits>

namespace almond::voxel {

using voxel_id = std::uint16_t;

enum class axis : std::uint8_t { x = 0, y = 1, z = 2 };

enum class block_face : std::uint8_t {
    pos_x = 0,
    neg_x = 1,
    pos_y = 2,
    neg_y = 3,
    pos_z = 4,
    neg_z = 5
};

constexpr std::size_t block_face_count = 6;

[[nodiscard]] constexpr axis axis_of(block_face face) noexcept {
    switch (face) {
    case block_face::pos_x:
    case block_face::neg_x:
        return axis::x;
    case block_face::pos_y:
    case block_face::neg_y:
        return axis::y;
    case block_face::pos_z:
    case block_face::neg_z:
    default:
        return axis::z;
    }
}

[[nodiscard]] constexpr int axis_sign(block_face face) noexcept {
    switch (face) {
    case block_face::pos_x:
    case block_face::pos_y:
    case block_face::pos_z:
        return 1;
    default:
        return -1;
    }
}

[[nodiscard]] constexpr block_face opposite(block_face face) noexcept {
    switch (face) {
    case block_face::pos_x:
        return block_face::neg_x;
    case block_face::neg_x:
        return block_face::pos_x;
    case block_face::pos_y:
        return block_face::neg_y;
    case block_face::neg_y:
        return block_face::pos_y;
    case block_face::pos_z:
        return block_face::neg_z;
    case block_face::neg_z:
    default:
        return block_face::pos_z;
    }
}

[[nodiscard]] constexpr std::array<int, 3> face_normal(block_face face) noexcept {
    switch (face) {
    case block_face::pos_x:
        return {1, 0, 0};
    case block_face::neg_x:
        return {-1, 0, 0};
    case block_face::pos_y:
        return {0, 1, 0};
    case block_face::neg_y:
        return {0, -1, 0};
    case block_face::pos_z:
        return {0, 0, 1};
    case block_face::neg_z:
    default:
        return {0, 0, -1};
    }
}

[[nodiscard]] constexpr std::string_view face_name(block_face face) noexcept {
    switch (face) {
    case block_face::pos_x:
        return "+X";
    case block_face::neg_x:
        return "-X";
    case block_face::pos_y:
        return "+Y";
    case block_face::neg_y:
        return "-Y";
    case block_face::pos_z:
        return "+Z";
    case block_face::neg_z:
    default:
        return "-Z";
    }
}

struct chunk_extent {
    std::uint32_t x{1};
    std::uint32_t y{1};
    std::uint32_t z{1};

    [[nodiscard]] constexpr std::array<std::uint32_t, 3> to_array() const noexcept {
        return {x, y, z};
    }

    [[nodiscard]] constexpr std::size_t volume() const noexcept {
        return static_cast<std::size_t>(x) * static_cast<std::size_t>(y) * static_cast<std::size_t>(z);
    }

    [[nodiscard]] constexpr bool contains(std::uint32_t px, std::uint32_t py, std::uint32_t pz) const noexcept {
        return px < x && py < y && pz < z;
    }

    [[nodiscard]] constexpr bool operator==(const chunk_extent&) const noexcept = default;
};

[[nodiscard]] constexpr chunk_extent cubic_extent(std::uint32_t edge) noexcept {
    return chunk_extent{edge, edge, edge};
}

template <typename T>
using voxel_span = std::span<T>;

template <typename T>
using voxel_cspan = std::span<const T>;

template <typename Element>
class span3d {
public:
    using element_type = Element;
    using value_type = std::remove_cv_t<Element>;
    using pointer = Element*;
    using reference = Element&;
    using size_type = std::size_t;

    constexpr span3d() noexcept = default;

    constexpr span3d(pointer data, chunk_extent extent) noexcept
        : data_{data}
        , extent_{extent} {
    }

    template <typename OtherElement>
    constexpr span3d(const span3d<OtherElement>& other) noexcept
        requires std::is_convertible_v<typename span3d<OtherElement>::pointer, pointer>
        : data_{other.data()}
        , extent_{other.extent()} {
    }

    [[nodiscard]] constexpr chunk_extent extent() const noexcept { return extent_; }

    [[nodiscard]] constexpr pointer data() const noexcept { return data_; }

    [[nodiscard]] constexpr size_type size() const noexcept { return extent_.volume(); }

    [[nodiscard]] constexpr bool empty() const noexcept { return data_ == nullptr || size() == 0; }

    [[nodiscard]] constexpr reference operator()(size_type px, size_type py, size_type pz) const noexcept {
        return data_[index(px, py, pz)];
    }

    [[nodiscard]] constexpr bool contains(size_type px, size_type py, size_type pz) const noexcept {
        return extent_.contains(static_cast<std::uint32_t>(px), static_cast<std::uint32_t>(py), static_cast<std::uint32_t>(pz));
    }

    [[nodiscard]] constexpr voxel_span<Element> linear() const noexcept {
        return voxel_span<Element>{data_, size()};
    }

    [[nodiscard]] constexpr size_type index(size_type px, size_type py, size_type pz) const noexcept {
        return px + static_cast<size_type>(extent_.x) * (py + static_cast<size_type>(extent_.y) * pz);
    }

private:
    pointer data_{nullptr};
    chunk_extent extent_{};
};

template <typename Element>
[[nodiscard]] constexpr span3d<Element> make_span3d(Element* data, chunk_extent extent) noexcept {
    return span3d<Element>{data, extent};
}

template <typename Element>
[[nodiscard]] constexpr span3d<const Element> make_span3d(const Element* data, chunk_extent extent) noexcept {
    return span3d<const Element>{data, extent};
}

} // namespace almond::voxel
// end: almond_voxel/core.hpp

// begin: almond_voxel/chunk.hpp


#include <algorithm>
#include <cstddef>
#include <functional>
#include <mutex>
#include <optional>
#include <span>
#include <stdexcept>
#include <utility>
#include <vector>

namespace almond::voxel {

class chunk_storage {
public:
    using byte_vector = std::vector<std::byte>;
    using compress_callback = std::function<byte_vector(voxel_cspan<voxel_id>)>;
    using decompress_callback = std::function<void(voxel_span<voxel_id>, std::span<const std::byte>)>;

    explicit chunk_storage(chunk_extent extent = cubic_extent(32));
    chunk_storage(const chunk_storage&) = delete;
    chunk_storage& operator=(const chunk_storage&) = delete;
    chunk_storage(chunk_storage&& other) noexcept;
    chunk_storage& operator=(chunk_storage&& other) noexcept;

    [[nodiscard]] chunk_extent extent() const noexcept { return extent_; }
    [[nodiscard]] std::size_t volume() const noexcept { return extent_.volume(); }

    [[nodiscard]] span3d<voxel_id> voxels() noexcept;
    [[nodiscard]] span3d<const voxel_id> voxels() const noexcept;

    [[nodiscard]] span3d<std::uint8_t> skylight() noexcept;
    [[nodiscard]] span3d<const std::uint8_t> skylight() const noexcept;

    [[nodiscard]] span3d<std::uint8_t> blocklight() noexcept;
    [[nodiscard]] span3d<const std::uint8_t> blocklight() const noexcept;

    [[nodiscard]] span3d<std::uint8_t> metadata() noexcept;
    [[nodiscard]] span3d<const std::uint8_t> metadata() const noexcept;

    void fill(voxel_id voxel, std::uint8_t sky_level = 0, std::uint8_t block_level = 0, std::uint8_t meta = 0);
    void assign_voxels(voxel_cspan<voxel_id> data);

    void set_compression_hooks(compress_callback compressor, decompress_callback decompressor = {});
    void request_compression() noexcept { compression_requested_ = true; }
    [[nodiscard]] bool flush_compression();
    [[nodiscard]] bool decompress();

    [[nodiscard]] bool compressed() const noexcept { return compressed_; }
    [[nodiscard]] std::span<const std::byte> compressed_blob() const noexcept { return compressed_blob_; }

    void clear_compression() {
        compression_requested_ = false;
        compressed_ = false;
        compressed_blob_.clear();
    }

    void mark_dirty(bool value = true) noexcept { dirty_ = value; }
    [[nodiscard]] bool dirty() const noexcept { return dirty_; }

private:
    void ensure_capacity();
    void ensure_decompressed();
    void decompress_locked();

    chunk_extent extent_{};
    std::vector<voxel_id> voxels_{};
    std::vector<std::uint8_t> skylight_{};
    std::vector<std::uint8_t> blocklight_{};
    std::vector<std::uint8_t> metadata_{};

    compress_callback compress_{};
    decompress_callback decompress_{};

    bool dirty_{false};
    bool compression_requested_{false};
    bool compressed_{false};
    byte_vector compressed_blob_{};
    std::mutex compression_mutex_{};
};

inline chunk_storage::chunk_storage(chunk_extent extent)
    : extent_{extent} {
    ensure_capacity();
}

inline chunk_storage::chunk_storage(chunk_storage&& other) noexcept
    : extent_{other.extent_}
    , voxels_{std::move(other.voxels_)}
    , skylight_{std::move(other.skylight_)}
    , blocklight_{std::move(other.blocklight_)}
    , metadata_{std::move(other.metadata_)}
    , compress_{std::move(other.compress_)}
    , decompress_{std::move(other.decompress_)}
    , dirty_{other.dirty_}
    , compression_requested_{other.compression_requested_}
    , compressed_{other.compressed_}
    , compressed_blob_{std::move(other.compressed_blob_)} {
    other.extent_ = chunk_extent{};
    other.dirty_ = false;
    other.compression_requested_ = false;
    other.compressed_ = false;
}

inline chunk_storage& chunk_storage::operator=(chunk_storage&& other) noexcept {
    if (this != &other) {
        std::scoped_lock lock{compression_mutex_, other.compression_mutex_};
        extent_ = other.extent_;
        voxels_ = std::move(other.voxels_);
        skylight_ = std::move(other.skylight_);
        blocklight_ = std::move(other.blocklight_);
        metadata_ = std::move(other.metadata_);
        compress_ = std::move(other.compress_);
        decompress_ = std::move(other.decompress_);
        dirty_ = other.dirty_;
        compression_requested_ = other.compression_requested_;
        compressed_ = other.compressed_;
        compressed_blob_ = std::move(other.compressed_blob_);

        other.extent_ = chunk_extent{};
        other.dirty_ = false;
        other.compression_requested_ = false;
        other.compressed_ = false;
        other.compressed_blob_.clear();
        other.compress_ = {};
        other.decompress_ = {};
    }
    return *this;
}

inline span3d<voxel_id> chunk_storage::voxels() noexcept {
    ensure_decompressed();
    mark_dirty();
    return make_span3d(voxels_.data(), extent_);
}

inline span3d<const voxel_id> chunk_storage::voxels() const noexcept {
    const_cast<chunk_storage*>(this)->ensure_decompressed();
    return make_span3d(voxels_.data(), extent_);
}

inline span3d<std::uint8_t> chunk_storage::skylight() noexcept {
    ensure_decompressed();
    mark_dirty();
    return make_span3d(skylight_.data(), extent_);
}

inline span3d<const std::uint8_t> chunk_storage::skylight() const noexcept {
    const_cast<chunk_storage*>(this)->ensure_decompressed();
    return make_span3d(skylight_.data(), extent_);
}

inline span3d<std::uint8_t> chunk_storage::blocklight() noexcept {
    ensure_decompressed();
    mark_dirty();
    return make_span3d(blocklight_.data(), extent_);
}

inline span3d<const std::uint8_t> chunk_storage::blocklight() const noexcept {
    const_cast<chunk_storage*>(this)->ensure_decompressed();
    return make_span3d(blocklight_.data(), extent_);
}

inline span3d<std::uint8_t> chunk_storage::metadata() noexcept {
    ensure_decompressed();
    mark_dirty();
    return make_span3d(metadata_.data(), extent_);
}

inline span3d<const std::uint8_t> chunk_storage::metadata() const noexcept {
    const_cast<chunk_storage*>(this)->ensure_decompressed();
    return make_span3d(metadata_.data(), extent_);
}

inline void chunk_storage::fill(voxel_id voxel, std::uint8_t sky_level, std::uint8_t block_level, std::uint8_t meta) {
    ensure_decompressed();
    std::fill(voxels_.begin(), voxels_.end(), voxel);
    std::fill(skylight_.begin(), skylight_.end(), sky_level);
    std::fill(blocklight_.begin(), blocklight_.end(), block_level);
    std::fill(metadata_.begin(), metadata_.end(), meta);
    mark_dirty();
}

inline void chunk_storage::assign_voxels(voxel_cspan<voxel_id> data) {
    ensure_decompressed();
    if (data.size() != voxels_.size()) {
        throw std::runtime_error("voxel data size mismatch");
    }
    std::copy(data.begin(), data.end(), voxels_.begin());
    mark_dirty();
}

inline void chunk_storage::set_compression_hooks(compress_callback compressor, decompress_callback decompressor) {
    std::scoped_lock lock{compression_mutex_};
    compress_ = std::move(compressor);
    decompress_ = std::move(decompressor);
}

inline bool chunk_storage::flush_compression() {
    std::scoped_lock lock{compression_mutex_};
    if (!compression_requested_ || !compress_) {
        return false;
    }
    decompress_locked();
    voxel_cspan<voxel_id> view = make_span3d(voxels_.data(), extent_).linear();
    compressed_blob_ = compress_(view);
    compression_requested_ = false;
    compressed_ = true;
    return true;
}

inline bool chunk_storage::decompress() {
    std::scoped_lock lock{compression_mutex_};
    if (!compressed_ || compressed_blob_.empty()) {
        return false;
    }
    decompress_locked();
    return true;
}

inline void chunk_storage::ensure_capacity() {
    const auto count = extent_.volume();
    voxels_.resize(count, voxel_id{});
    skylight_.resize(count, std::uint8_t{});
    blocklight_.resize(count, std::uint8_t{});
    metadata_.resize(count, std::uint8_t{});
}

inline void chunk_storage::ensure_decompressed() {
    if (compressed_) {
        std::scoped_lock lock{compression_mutex_};
        decompress_locked();
    }
}

inline void chunk_storage::decompress_locked() {
    if (!compressed_ || compressed_blob_.empty()) {
        return;
    }
    if (decompress_) {
        decompress_(make_span3d(voxels_.data(), extent_).linear(), compressed_blob_);
    }
    compressed_blob_.clear();
    compressed_ = false;
}

} // namespace almond::voxel
// end: almond_voxel/chunk.hpp

// begin: almond_voxel/world.hpp


#include <algorithm>
#include <cstdint>
#include <deque>
#include <functional>
#include <limits>
#include <memory>
#include <unordered_map>
#include <utility>
#include <vector>

namespace almond::voxel {

struct region_key {
    std::int32_t x{0};
    std::int32_t y{0};
    std::int32_t z{0};

    [[nodiscard]] friend constexpr bool operator==(const region_key& lhs, const region_key& rhs) noexcept = default;
};

struct region_key_hash {
    [[nodiscard]] std::size_t operator()(const region_key& key) const noexcept {
        std::uint64_t hx = static_cast<std::uint64_t>(key.x);
        std::uint64_t hy = static_cast<std::uint64_t>(key.y);
        std::uint64_t hz = static_cast<std::uint64_t>(key.z);
        std::uint64_t hash = hx * 0x9E3779B185EBCA87ull;
        hash ^= hy + 0x9E3779B97F4A7C15ull + (hash << 6) + (hash >> 2);
        hash ^= hz + 0xC2B2AE3D27D4EB4Full + (hash << 6) + (hash >> 2);
        return static_cast<std::size_t>(hash);
    }
};

class region_manager {
public:
    using chunk_ptr = std::shared_ptr<chunk_storage>;
    using loader_type = std::function<chunk_storage(const region_key&)>;
    using saver_type = std::function<void(const region_key&, const chunk_storage&)>;
    using task_type = std::function<void(chunk_storage&, const region_key&)>;

    explicit region_manager(chunk_extent chunk_dimensions = cubic_extent(32));

    [[nodiscard]] chunk_extent chunk_dimensions() const noexcept { return chunk_extent_; }

    chunk_storage& assure(const region_key& key);
    [[nodiscard]] chunk_ptr find(const region_key& key) const;

    void set_loader(loader_type loader) { loader_ = std::move(loader); }
    void set_saver(saver_type saver) { saver_ = std::move(saver); }

    void set_max_resident(std::size_t limit) noexcept;
    [[nodiscard]] std::size_t max_resident() const noexcept { return max_resident_; }
    [[nodiscard]] std::size_t resident() const noexcept { return regions_.size(); }

    void pin(const region_key& key);
    void unpin(const region_key& key);

    void enqueue_task(const region_key& key, task_type task);
    std::size_t tick(std::size_t budget = std::numeric_limits<std::size_t>::max());

    void for_each_loaded(const std::function<void(const region_key&, const chunk_storage&)>& visitor) const;

    struct region_snapshot {
        region_key key{};
        std::shared_ptr<const chunk_storage> chunk;
    };

    [[nodiscard]] std::vector<region_snapshot> snapshot_loaded(bool include_clean = false) const;

    bool unload(const region_key& key);
    void evict_until_within_limit();

private:
    struct entry {
        chunk_ptr chunk;
        bool pinned{false};
    };

    chunk_storage& load_or_create(const region_key& key);
    void touch(const region_key& key);

    chunk_extent chunk_extent_{};
    std::unordered_map<region_key, entry, region_key_hash> regions_{};
    std::deque<region_key> lru_{};
    std::size_t max_resident_{128};
    loader_type loader_{};
    saver_type saver_{};
    std::deque<std::pair<region_key, task_type>> task_queue_{};
};

inline region_manager::region_manager(chunk_extent chunk_dimensions)
    : chunk_extent_{chunk_dimensions} {
}

inline chunk_storage& region_manager::assure(const region_key& key) {
    auto& chunk = load_or_create(key);
    touch(key);
    return chunk;
}

inline region_manager::chunk_ptr region_manager::find(const region_key& key) const {
    if (auto it = regions_.find(key); it != regions_.end()) {
        return it->second.chunk;
    }
    return {};
}

inline void region_manager::set_max_resident(std::size_t limit) noexcept {
    max_resident_ = limit;
    evict_until_within_limit();
}

inline void region_manager::pin(const region_key& key) {
    if (auto it = regions_.find(key); it != regions_.end()) {
        it->second.pinned = true;
    }
}

inline void region_manager::unpin(const region_key& key) {
    if (auto it = regions_.find(key); it != regions_.end()) {
        it->second.pinned = false;
        touch(key);
    }
}

inline void region_manager::enqueue_task(const region_key& key, task_type task) {
    task_queue_.emplace_back(key, std::move(task));
}

inline std::size_t region_manager::tick(std::size_t budget) {
    std::size_t processed = 0;
    while (processed < budget && !task_queue_.empty()) {
        auto [key, task] = std::move(task_queue_.front());
        task_queue_.pop_front();
        auto& chunk = assure(key);
        if (task) {
            task(chunk, key);
        }
        ++processed;
    }
    evict_until_within_limit();
    return processed;
}

inline void region_manager::for_each_loaded(const std::function<void(const region_key&, const chunk_storage&)>& visitor) const {
    for (const auto& [key, entry] : regions_) {
        if (entry.chunk) {
            visitor(key, *entry.chunk);
        }
    }
}

inline std::vector<region_manager::region_snapshot> region_manager::snapshot_loaded(bool include_clean) const {
    std::vector<region_snapshot> snapshots;
    snapshots.reserve(regions_.size());
    for (const auto& [key, entry] : regions_) {
        if (!entry.chunk) {
            continue;
        }
        if (!include_clean && !entry.chunk->dirty()) {
            continue;
        }
        snapshots.push_back(region_snapshot{key, std::const_pointer_cast<const chunk_storage>(entry.chunk)});
    }
    return snapshots;
}

inline bool region_manager::unload(const region_key& key) {
    auto it = regions_.find(key);
    if (it == regions_.end()) {
        return false;
    }
    if (it->second.pinned) {
        return false;
    }
    if (it->second.chunk && saver_ && it->second.chunk->dirty()) {
        saver_(key, *it->second.chunk);
    }
    regions_.erase(it);
    return true;
}

inline void region_manager::evict_until_within_limit() {
    while (regions_.size() > max_resident_ && !lru_.empty()) {
        const auto key = lru_.front();
        lru_.pop_front();
        auto it = regions_.find(key);
        if (it == regions_.end() || it->second.pinned) {
            continue;
        }
        if (it->second.chunk && saver_ && it->second.chunk->dirty()) {
            saver_(key, *it->second.chunk);
        }
        regions_.erase(it);
    }
}

inline chunk_storage& region_manager::load_or_create(const region_key& key) {
    if (auto it = regions_.find(key); it != regions_.end()) {
        return *it->second.chunk;
    }
    chunk_ptr chunk;
    if (loader_) {
        chunk = std::make_shared<chunk_storage>(loader_(key));
    } else {
        chunk = std::make_shared<chunk_storage>(chunk_extent_);
    }
    auto [it, inserted] = regions_.emplace(key, entry{std::move(chunk), false});
    (void)inserted;
    return *it->second.chunk;
}

inline void region_manager::touch(const region_key& key) {
    std::erase(lru_, key);
    lru_.push_back(key);
}

} // namespace almond::voxel
// end: almond_voxel/world.hpp

// begin: almond_voxel/editing/voxel_editing.hpp


#include <array>
#include <cstdint>
#include <utility>

namespace almond::voxel::editing {

struct world_position {
    std::int64_t x{0};
    std::int64_t y{0};
    std::int64_t z{0};
};

struct chunk_coordinates {
    region_key region{};
    std::array<std::uint32_t, 3> local{};
};

namespace detail {

inline std::pair<std::int32_t, std::uint32_t> floor_divmod(std::int64_t value, std::uint32_t divisor) {
    const std::int64_t denom = static_cast<std::int64_t>(divisor);
    std::int64_t quotient = value / denom;
    std::int64_t remainder = value % denom;
    if (remainder < 0) {
        remainder += denom;
        --quotient;
    }
    return {static_cast<std::int32_t>(quotient), static_cast<std::uint32_t>(remainder)};
}

} // namespace detail

inline chunk_coordinates split_world_position(const world_position& position, const chunk_extent& extent) {
    auto [rx, lx] = detail::floor_divmod(position.x, extent.x);
    auto [ry, ly] = detail::floor_divmod(position.y, extent.y);
    auto [rz, lz] = detail::floor_divmod(position.z, extent.z);
    chunk_coordinates coords{};
    coords.region = region_key{rx, ry, rz};
    coords.local = {lx, ly, lz};
    return coords;
}

inline std::size_t linear_index(const chunk_extent& extent, const std::array<std::uint32_t, 3>& local) {
    return static_cast<std::size_t>(local[0])
        + static_cast<std::size_t>(extent.x) * (static_cast<std::size_t>(local[1])
              + static_cast<std::size_t>(extent.y) * static_cast<std::size_t>(local[2]));
}

inline bool set_voxel(chunk_storage& chunk, const std::array<std::uint32_t, 3>& local, voxel_id id) {
    auto vox = chunk.voxels();
    if (!vox.contains(local[0], local[1], local[2])) {
        return false;
    }
    vox(local[0], local[1], local[2]) = id;
    return true;
}

inline bool clear_voxel(chunk_storage& chunk, const std::array<std::uint32_t, 3>& local) {
    return set_voxel(chunk, local, voxel_id{});
}

inline bool set_voxel(region_manager& regions, const world_position& position, voxel_id id) {
    const auto coords = split_world_position(position, regions.chunk_dimensions());
    auto& chunk = regions.assure(coords.region);
    return set_voxel(chunk, coords.local, id);
}

inline bool clear_voxel(region_manager& regions, const world_position& position) {
    return set_voxel(regions, position, voxel_id{});
}

inline bool toggle_voxel(region_manager& regions, const world_position& position, voxel_id on_value) {
    const auto coords = split_world_position(position, regions.chunk_dimensions());
    auto& chunk = regions.assure(coords.region);
    auto vox = chunk.voxels();
    if (!vox.contains(coords.local[0], coords.local[1], coords.local[2])) {
        return false;
    }
    voxel_id& value = vox(coords.local[0], coords.local[1], coords.local[2]);
    value = value == voxel_id{} ? on_value : voxel_id{};
    return true;
}

} // namespace almond::voxel::editing
// end: almond_voxel/editing/voxel_editing.hpp

// begin: almond_voxel/generation/noise.hpp


#include <algorithm>
#include <cmath>
#include <cstdint>
#include <vector>

namespace almond::voxel::generation {

class value_noise {
public:
    explicit value_noise(std::uint64_t seed = 0, double frequency = 1.0, std::size_t octaves = 4, double persistence = 0.5) noexcept
        : seed_{seed}
        , frequency_{frequency}
        , octaves_{octaves}
        , persistence_{persistence} {
    }

    [[nodiscard]] double sample(double x, double y, double z = 0.0) const noexcept {
        double amplitude = 1.0;
        double frequency = frequency_;
        double sum = 0.0;
        double max_amplitude = 0.0;
        for (std::size_t octave = 0; octave < octaves_; ++octave) {
            sum += amplitude * gradient_noise(x * frequency, y * frequency, z * frequency);
            max_amplitude += amplitude;
            amplitude *= persistence_;
            frequency *= 2.0;
        }
        if (max_amplitude == 0.0) {
            return 0.0;
        }
        return sum / max_amplitude;
    }

private:
    [[nodiscard]] double gradient_noise(double x, double y, double z) const noexcept {
        const auto xi = static_cast<std::int64_t>(std::floor(x));
        const auto yi = static_cast<std::int64_t>(std::floor(y));
        const auto zi = static_cast<std::int64_t>(std::floor(z));
        const double xf = x - static_cast<double>(xi);
        const double yf = y - static_cast<double>(yi);
        const double zf = z - static_cast<double>(zi);

        const double u = fade(xf);
        const double v = fade(yf);
        const double w = fade(zf);

        const double c000 = grad(hash(xi, yi, zi), xf, yf, zf);
        const double c100 = grad(hash(xi + 1, yi, zi), xf - 1.0, yf, zf);
        const double c010 = grad(hash(xi, yi + 1, zi), xf, yf - 1.0, zf);
        const double c110 = grad(hash(xi + 1, yi + 1, zi), xf - 1.0, yf - 1.0, zf);
        const double c001 = grad(hash(xi, yi, zi + 1), xf, yf, zf - 1.0);
        const double c101 = grad(hash(xi + 1, yi, zi + 1), xf - 1.0, yf, zf - 1.0);
        const double c011 = grad(hash(xi, yi + 1, zi + 1), xf, yf - 1.0, zf - 1.0);
        const double c111 = grad(hash(xi + 1, yi + 1, zi + 1), xf - 1.0, yf - 1.0, zf - 1.0);

        const double x00 = lerp(c000, c100, u);
        const double x10 = lerp(c010, c110, u);
        const double x01 = lerp(c001, c101, u);
        const double x11 = lerp(c011, c111, u);

        const double y0 = lerp(x00, x10, v);
        const double y1 = lerp(x01, x11, v);

        return lerp(y0, y1, w);
    }

    [[nodiscard]] static constexpr double fade(double t) noexcept {
        return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
    }

    [[nodiscard]] static constexpr double lerp(double a, double b, double t) noexcept {
        return a + t * (b - a);
    }

    [[nodiscard]] double grad(std::uint64_t hash_value, double x, double y, double z) const noexcept {
        const std::uint64_t h = hash_value & 15ull;
        const double u = h < 8ull ? x : y;
        const double v = h < 4ull ? y : (h == 12ull || h == 14ull ? x : z);
        const double first = (h & 1ull) == 0ull ? u : -u;
        const double second = (h & 2ull) == 0ull ? v : -v;
        return first + second;
    }

    [[nodiscard]] std::uint64_t hash(std::int64_t x, std::int64_t y, std::int64_t z) const noexcept {
        std::uint64_t h = seed_;
        h ^= static_cast<std::uint64_t>(x) * 0x9E3779B185EBCA87ull;
        h ^= static_cast<std::uint64_t>(y) * 0xC2B2AE3D27D4EB4Full;
        h ^= static_cast<std::uint64_t>(z) * 0x165667B19E3779F9ull;
        h ^= (h >> 33);
        h *= 0xff51afd7ed558ccdull;
        h ^= (h >> 33);
        h *= 0xc4ceb9fe1a85ec53ull;
        h ^= (h >> 33);
        return h;
    }

    std::uint64_t seed_;
    double frequency_;
    std::size_t octaves_;
    double persistence_;
};

struct palette_entry {
    double threshold{0.0};
    voxel_id id{0};
};

class palette_builder {
public:
    palette_builder& add(double threshold, voxel_id id) {
        entries_.push_back(palette_entry{threshold, id});
        std::sort(entries_.begin(), entries_.end(), [](const auto& lhs, const auto& rhs) {
            return lhs.threshold < rhs.threshold;
        });
        return *this;
    }

    [[nodiscard]] voxel_id choose(double value) const noexcept {
        if (entries_.empty()) {
            return voxel_id{};
        }
        for (const auto& entry : entries_) {
            if (value <= entry.threshold) {
                return entry.id;
            }
        }
        return entries_.back().id;
    }

    [[nodiscard]] const std::vector<palette_entry>& entries() const noexcept { return entries_; }

private:
    std::vector<palette_entry> entries_{};
};

[[nodiscard]] inline double remap(double value, double min, double max) noexcept {
    if (min == max) {
        return 0.0;
    }
    const double clamped = std::clamp(value, min, max);
    return (clamped - min) / (max - min);
}

template <typename OutputIt>
void sample_heightmap(const value_noise& noise, const chunk_extent& extent, double scale, OutputIt out) {
    const auto dims = extent.to_array();
    for (std::uint32_t z = 0; z < dims[2]; ++z) {
        for (std::uint32_t x = 0; x < dims[0]; ++x) {
            const double nx = static_cast<double>(x) / static_cast<double>(dims[0]);
            const double nz = static_cast<double>(z) / static_cast<double>(dims[2]);
            *out++ = noise.sample(nx * scale, nz * scale);
        }
    }
}

template <typename Range>
[[nodiscard]] std::vector<voxel_id> build_palette(const Range& samples, const palette_builder& palette) {
    std::vector<voxel_id> result;
    result.reserve(samples.size());
    if (samples.empty()) {
        return result;
    }
    const auto [min_it, max_it] = std::minmax_element(samples.begin(), samples.end());
    const double min_v = *min_it;
    const double max_v = *max_it;
    for (const auto& value : samples) {
        result.push_back(palette.choose(remap(value, min_v, max_v)));
    }
    return result;
}

} // namespace almond::voxel::generation
// end: almond_voxel/generation/noise.hpp

// begin: almond_voxel/meshing/mesh_types.hpp


#include <array>
#include <cstdint>
#include <vector>

namespace almond::voxel::meshing {

struct vertex {
    std::array<float, 3> position{};
    std::array<float, 3> normal{};
    std::array<float, 2> uv{};
    voxel_id id{0};
};

struct mesh_result {
    std::vector<vertex> vertices;
    std::vector<std::uint32_t> indices;
};

} // namespace almond::voxel::meshing
// end: almond_voxel/meshing/mesh_types.hpp

// begin: almond_voxel/meshing/neighbors.hpp


#include <array>
#include <cstddef>
#include <cstdint>

namespace almond::voxel::meshing {

struct chunk_neighbors {
    const chunk_storage* pos_x{nullptr};
    const chunk_storage* neg_x{nullptr};
    const chunk_storage* pos_y{nullptr};
    const chunk_storage* neg_y{nullptr};
    const chunk_storage* pos_z{nullptr};
    const chunk_storage* neg_z{nullptr};

    [[nodiscard]] const chunk_storage* get(block_face face) const noexcept {
        switch (face) {
        case block_face::pos_x:
            return pos_x;
        case block_face::neg_x:
            return neg_x;
        case block_face::pos_y:
            return pos_y;
        case block_face::neg_y:
            return neg_y;
        case block_face::pos_z:
            return pos_z;
        case block_face::neg_z:
        default:
            return neg_z;
        }
    }
};

namespace detail {

struct neighbor_view {
    span3d<const voxel_id> voxels{};
    chunk_extent extent{};
    bool available{false};
};

inline std::array<neighbor_view, block_face_count> load_neighbor_views(const chunk_neighbors& neighbors) {
    std::array<neighbor_view, block_face_count> result{};

    const auto assign = [&](block_face face, const chunk_storage* storage) {
        if (storage == nullptr) {
            return;
        }
        auto& entry = result[static_cast<std::size_t>(face)];
        entry.voxels = storage->voxels();
        entry.extent = storage->extent();
        entry.available = true;
    };

    assign(block_face::pos_x, neighbors.pos_x);
    assign(block_face::neg_x, neighbors.neg_x);
    assign(block_face::pos_y, neighbors.pos_y);
    assign(block_face::neg_y, neighbors.neg_y);
    assign(block_face::pos_z, neighbors.pos_z);
    assign(block_face::neg_z, neighbors.neg_z);

    return result;
}

inline bool remap_to_neighbor_coords(const chunk_extent& extent, std::array<std::ptrdiff_t, 3>& coord,
    const std::array<neighbor_view, block_face_count>& neighbors, const neighbor_view*& out_view) {
    const std::array<std::ptrdiff_t, 3> dims{
        static_cast<std::ptrdiff_t>(extent.x),
        static_cast<std::ptrdiff_t>(extent.y),
        static_cast<std::ptrdiff_t>(extent.z)
    };

    int out_of_bounds_axes = 0;
    block_face face = block_face::pos_x;

    if (coord[0] < 0) {
        face = block_face::neg_x;
        ++out_of_bounds_axes;
    } else if (coord[0] >= dims[0]) {
        face = block_face::pos_x;
        ++out_of_bounds_axes;
    }

    if (coord[1] < 0) {
        face = block_face::neg_y;
        ++out_of_bounds_axes;
    } else if (coord[1] >= dims[1]) {
        face = block_face::pos_y;
        ++out_of_bounds_axes;
    }

    if (coord[2] < 0) {
        face = block_face::neg_z;
        ++out_of_bounds_axes;
    } else if (coord[2] >= dims[2]) {
        face = block_face::pos_z;
        ++out_of_bounds_axes;
    }

    if (out_of_bounds_axes != 1) {
        return false;
    }

    const auto index = static_cast<std::size_t>(face);
    const auto& view = neighbors[index];
    if (!view.available) {
        return false;
    }

    switch (face) {
    case block_face::neg_x:
        coord[0] += static_cast<std::ptrdiff_t>(view.extent.x);
        break;
    case block_face::pos_x:
        coord[0] -= dims[0];
        break;
    case block_face::neg_y:
        coord[1] += static_cast<std::ptrdiff_t>(view.extent.y);
        break;
    case block_face::pos_y:
        coord[1] -= dims[1];
        break;
    case block_face::neg_z:
        coord[2] += static_cast<std::ptrdiff_t>(view.extent.z);
        break;
    case block_face::pos_z:
        coord[2] -= dims[2];
        break;
    }

    if (coord[0] < 0 || coord[0] >= static_cast<std::ptrdiff_t>(view.extent.x) || coord[1] < 0
        || coord[1] >= static_cast<std::ptrdiff_t>(view.extent.y) || coord[2] < 0
        || coord[2] >= static_cast<std::ptrdiff_t>(view.extent.z)) {
        return false;
    }

    out_view = &view;
    return true;
}

} // namespace detail

} // namespace almond::voxel::meshing
// end: almond_voxel/meshing/neighbors.hpp

// begin: almond_voxel/meshing/greedy_mesher.hpp


#include <array>
#include <cstddef>
#include <cstdint>
#include <utility>
#include <vector>

namespace almond::voxel::meshing {

template <typename IsOpaque, typename NeighborOpaque>
[[nodiscard]] mesh_result greedy_mesh_with_neighbors(const chunk_storage& chunk, IsOpaque&& is_opaque,
    NeighborOpaque&& neighbor_opaque) {
    mesh_result result;
    const auto extent = chunk.extent();
    const auto dims = extent.to_array();
    const auto voxels = chunk.voxels();

    struct mask_cell {
        bool filled{false};
        voxel_id id{0};
    };

    const std::array faces{block_face::pos_x, block_face::neg_x, block_face::pos_y, block_face::neg_y, block_face::pos_z, block_face::neg_z};
    constexpr float vertical_face_bias = 0.001f;

    for (auto face : faces) {
        const std::size_t axis = static_cast<std::size_t>(axis_of(face));
        const int sign = axis_sign(face);
        const std::size_t u_axis = (axis + 1) % 3;
        const std::size_t v_axis = (axis + 2) % 3;
        const std::size_t du = dims[u_axis];
        const std::size_t dv = dims[v_axis];

        std::vector<mask_cell> mask(du * dv);

        for (std::size_t plane = 0; plane < dims[axis]; ++plane) {
            std::fill(mask.begin(), mask.end(), mask_cell{});

            for (std::size_t v = 0; v < dv; ++v) {
                for (std::size_t u = 0; u < du; ++u) {
                    const std::size_t idx = u + v * du;
                    std::array<std::size_t, 3> pos{};
                    pos[axis] = plane;
                    pos[u_axis] = u;
                    pos[v_axis] = v;

                    const voxel_id current = voxels(pos[0], pos[1], pos[2]);
                    if (!is_opaque(current)) {
                        continue;
                    }

                    bool neighbor_inside = true;
                    std::array<std::size_t, 3> neighbor = pos;
                    if (sign > 0) {
                        neighbor[axis] = pos[axis] + 1;
                        neighbor_inside = neighbor[axis] < dims[axis];
                    } else {
                        neighbor_inside = pos[axis] > 0;
                        if (neighbor_inside) {
                            neighbor[axis] = pos[axis] - 1;
                        }
                    }

                    bool neighbor_solid = false;
                    if (neighbor_inside) {
                        neighbor_solid = is_opaque(voxels(neighbor[0], neighbor[1], neighbor[2]));
                    } else {
                        std::array<std::ptrdiff_t, 3> neighbor_local{
                            static_cast<std::ptrdiff_t>(pos[0]),
                            static_cast<std::ptrdiff_t>(pos[1]),
                            static_cast<std::ptrdiff_t>(pos[2])
                        };
                        neighbor_local[axis] += sign;
                        neighbor_solid = neighbor_opaque(neighbor_local);
                    }

                    if (!neighbor_solid) {
                        mask[idx] = mask_cell{true, current};
                    }
                }
            }

            for (std::size_t v = 0; v < dv; ++v) {
                for (std::size_t u = 0; u < du; ++u) {
                    const std::size_t idx = u + v * du;
                    auto& cell = mask[idx];
                    if (!cell.filled) {
                        continue;
                    }

                    std::size_t width = 1;
                    while (u + width < du) {
                        const auto& next = mask[idx + width];
                        if (!next.filled || next.id != cell.id) {
                            break;
                        }
                        ++width;
                    }

                    std::size_t height = 1;
                    bool stop = false;
                    while (v + height < dv && !stop) {
                        for (std::size_t x = 0; x < width; ++x) {
                            const auto& next = mask[idx + x + height * du];
                            if (!next.filled || next.id != cell.id) {
                                stop = true;
                                break;
                            }
                        }
                        if (!stop) {
                            ++height;
                        }
                    }

                    float axis_coord = static_cast<float>(plane + (sign > 0 ? 1 : 0));
                    if (axis == 2) {
                        axis_coord += sign > 0 ? vertical_face_bias : -vertical_face_bias;
                    }
                    std::array<float, 3> base{0.0f, 0.0f, 0.0f};
                    base[axis] = axis_coord;
                    base[u_axis] = static_cast<float>(u);
                    base[v_axis] = static_cast<float>(v);

                    std::array<float, 3> du_vec{0.0f, 0.0f, 0.0f};
                    du_vec[u_axis] = static_cast<float>(width);
                    std::array<float, 3> dv_vec{0.0f, 0.0f, 0.0f};
                    dv_vec[v_axis] = static_cast<float>(height);

                    std::array<std::array<float, 3>, 4> corners{
                        base,
                        std::array<float, 3>{base[0] + du_vec[0], base[1] + du_vec[1], base[2] + du_vec[2]},
                        std::array<float, 3>{base[0] + du_vec[0] + dv_vec[0], base[1] + du_vec[1] + dv_vec[1], base[2] + du_vec[2] + dv_vec[2]},
                        std::array<float, 3>{base[0] + dv_vec[0], base[1] + dv_vec[1], base[2] + dv_vec[2]}
                    };

                    std::array<std::array<float, 2>, 4> uv{
                        std::array<float, 2>{0.0f, 0.0f},
                        std::array<float, 2>{static_cast<float>(width), 0.0f},
                        std::array<float, 2>{static_cast<float>(width), static_cast<float>(height)},
                        std::array<float, 2>{0.0f, static_cast<float>(height)}
                    };

                    const auto normal_i = face_normal(face);
                    const std::array<float, 3> normal{static_cast<float>(normal_i[0]), static_cast<float>(normal_i[1]), static_cast<float>(normal_i[2])};

                    const auto base_index = static_cast<std::uint32_t>(result.vertices.size());
                    for (std::size_t i = 0; i < 4; ++i) {
                        result.vertices.push_back(vertex{corners[i], normal, uv[i], cell.id});
                    }

                    if (sign > 0) {
                        result.indices.insert(result.indices.end(), {base_index, base_index + 1, base_index + 2, base_index, base_index + 2, base_index + 3});
                    } else {
                        result.indices.insert(result.indices.end(), {base_index, base_index + 2, base_index + 1, base_index, base_index + 3, base_index + 2});
                    }

                    for (std::size_t dy = 0; dy < height; ++dy) {
                        for (std::size_t dx = 0; dx < width; ++dx) {
                            mask[u + dx + (v + dy) * du].filled = false;
                        }
                    }
                }
            }
        }
    }

    return result;
}

template <typename IsOpaque>
[[nodiscard]] mesh_result greedy_mesh_with_neighbor_chunks(const chunk_storage& chunk, const chunk_neighbors& neighbors,
    IsOpaque&& is_opaque) {
    const auto neighbor_views = detail::load_neighbor_views(neighbors);
    auto neighbor_sampler = [&, dims = chunk.extent()](const std::array<std::ptrdiff_t, 3>& coord) {
        std::array<std::ptrdiff_t, 3> local = coord;
        const detail::neighbor_view* view = nullptr;
        if (!detail::remap_to_neighbor_coords(dims, local, neighbor_views, view)) {
            return false;
        }

        return is_opaque(view->voxels(static_cast<std::size_t>(local[0]), static_cast<std::size_t>(local[1]),
            static_cast<std::size_t>(local[2])));
    };

    return greedy_mesh_with_neighbors(chunk, std::forward<IsOpaque>(is_opaque), neighbor_sampler);
}

inline mesh_result greedy_mesh_with_neighbor_chunks(const chunk_storage& chunk, const chunk_neighbors& neighbors) {
    return greedy_mesh_with_neighbor_chunks(chunk, neighbors, [](voxel_id id) { return id != voxel_id{}; });
}

template <typename IsOpaque>
[[nodiscard]] mesh_result greedy_mesh(const chunk_storage& chunk, IsOpaque&& is_opaque) {
    auto neighbor = [](const std::array<std::ptrdiff_t, 3>&) { return false; };
    return greedy_mesh_with_neighbors(chunk, std::forward<IsOpaque>(is_opaque), neighbor);
}

inline mesh_result greedy_mesh(const chunk_storage& chunk) {
    return greedy_mesh(chunk, [](voxel_id id) { return id != voxel_id{}; });
}

} // namespace almond::voxel::meshing
// end: almond_voxel/meshing/greedy_mesher.hpp

// begin: almond_voxel/meshing/marching_cubes_tables.hpp

#include <array>
#include <cstdint>

namespace almond::voxel::meshing::detail {

    inline constexpr std::array<int, 256> mc_edge_table{
        0x000, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
        0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
        0x190, 0x099, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
        0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
        0x230, 0x339, 0x033, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
        0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
        0x3a0, 0x2a9, 0x1a3, 0x0aa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
        0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
        0x460, 0x569, 0x663, 0x76a, 0x066, 0x16f, 0x265, 0x36c,
        0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
        0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0x0ff, 0x3f5, 0x2fc,
        0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
        0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x055, 0x15c,
        0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
        0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0x0cc,
        0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
        0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
        0x0cc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
        0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
        0x15c, 0x055, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
        0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
        0x2fc, 0x3f5, 0x0ff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
        0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
        0x36c, 0x265, 0x16f, 0x066, 0x76a, 0x663, 0x569, 0x460,
        0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
        0x4ac, 0x5a5, 0x6af, 0x7a6, 0x0aa, 0x1a3, 0x2a9, 0x3a0,
        0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
        0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x033, 0x339, 0x230,
        0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
        0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x099, 0x190,
        0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
        0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x000
    };

    inline constexpr std::array<std::array<int, 32>, 256> mc_triangle_table
    {
        {
            {{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1}},
            {{3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1}},
            {{3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1}},
            {{3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1}},
            {{2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1}},
            {{8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1}},
            {{4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1}},
            {{3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1}},
            {{4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1}},
            {{4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1}},
            {{5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1}},
            {{2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1}},
            {{9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1}},
            {{2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1}},
            {{10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1}},
            {{4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1}},
            {{5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1}},
            {{5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1}},
            {{10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1}},
            {{8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1}},
            {{2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1}},
            {{7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1}},
            {{2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1}},
            {{11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1}},
            {{5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1}},
            {{11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1}},
            {{11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1}},
            {{5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1}},
            {{2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1}},
            {{5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1}},
            {{6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1}},
            {{3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1}},
            {{6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1}},
            {{5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1}},
            {{10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1}},
            {{6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1}},
            {{8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1}},
            {{7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1}},
            {{3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1}},
            {{5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1}},
            {{0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1}},
            {{9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1}},
            {{8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1}},
            {{5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1}},
            {{0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1}},
            {{6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1}},
            {{10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1}},
            {{10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1}},
            {{8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1}},
            {{1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1}},
            {{3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1}},
            {{0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1}},
            {{10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1}},
            {{3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1}},
            {{6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1}},
            {{9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1}},
            {{8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1}},
            {{3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1}},
            {{6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1}},
            {{10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1}},
            {{10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1}},
            {{2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1}},
            {{7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1}},
            {{7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1}},
            {{2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1}},
            {{1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1}},
            {{11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1}},
            {{8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1}},
            {{0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1}},
            {{7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1}},
            {{10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1}},
            {{2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1}},
            {{6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1}},
            {{7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1}},
            {{2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1}},
            {{10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1}},
            {{10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1}},
            {{0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1}},
            {{7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1}},
            {{6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1}},
            {{8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1}},
            {{6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1}},
            {{4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1}},
            {{10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1}},
            {{8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1}},
            {{1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1}},
            {{8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1}},
            {{10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1}},
            {{4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1}},
            {{10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1}},
            {{5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1}},
            {{11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1}},
            {{9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1}},
            {{6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1}},
            {{7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1}},
            {{3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1}},
            {{7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1}},
            {{3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1}},
            {{6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1}},
            {{9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1}},
            {{1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1}},
            {{4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1}},
            {{7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1}},
            {{6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1}},
            {{3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1}},
            {{0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1}},
            {{6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1}},
            {{0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1}},
            {{11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1}},
            {{6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1}},
            {{5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1}},
            {{9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1}},
            {{1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1}},
            {{10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1}},
            {{0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1}},
            {{5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1}},
            {{10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1}},
            {{11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1}},
            {{9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1}},
            {{7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1}},
            {{2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1}},
            {{8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1}},
            {{9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1}},
            {{9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1}},
            {{1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1}},
            {{5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1}},
            {{0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1}},
            {{10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1}},
            {{2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1}},
            {{0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1}},
            {{0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1}},
            {{9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1}},
            {{5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1}},
            {{3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1}},
            {{5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1}},
            {{8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1}},
            {{9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1}},
            {{1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1}},
            {{3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1}},
            {{4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1}},
            {{9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1}},
            {{11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1}},
            {{11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1}},
            {{2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1}},
            {{9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1}},
            {{3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1}},
            {{1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1}},
            {{4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1}},
            {{4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1}},
            {{3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1}},
            {{3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1}},
            {{0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1}},
            {{9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1}},
            {{1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}},
            {{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}
        }
    };

} // namespace almond::voxel::meshing::detail
// end: almond_voxel/meshing/marching_cubes_tables.hpp

// begin: almond_voxel/meshing/marching_cubes.hpp


#include <array>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <optional>
#include <utility>

namespace almond::voxel::meshing {

struct marching_cubes_config {
    // Scalar threshold for the implicit surface. Sample values strictly below the iso value are
    // classified as solid, while values greater than or equal to the iso value are treated as empty.
    float iso_value{0.5f};
};

namespace detail {

inline constexpr std::array<std::array<int, 3>, 8> cube_corners{{
    {{0, 0, 0}},
    {{1, 0, 0}},
    {{1, 1, 0}},
    {{0, 1, 0}},
    {{0, 0, 1}},
    {{1, 0, 1}},
    {{1, 1, 1}},
    {{0, 1, 1}},
}};

inline constexpr std::array<std::array<int, 2>, 12> edge_connection{{
    {{0, 1}},
    {{1, 2}},
    {{2, 3}},
    {{3, 0}},
    {{4, 5}},
    {{5, 6}},
    {{6, 7}},
    {{7, 4}},
    {{0, 4}},
    {{1, 5}},
    {{2, 6}},
    {{3, 7}},
}};

inline std::array<float, 3> interpolate_vertex(const std::array<float, 3>& p0, const std::array<float, 3>& p1,
    float v0, float v1, float iso_value) {
    const float delta = v1 - v0;
    if (std::abs(delta) < 1e-6f) {
        return p0;
    }
    const float mu = (iso_value - v0) / delta;
    return std::array<float, 3>{
        p0[0] + mu * (p1[0] - p0[0]),
        p0[1] + mu * (p1[1] - p0[1]),
        p0[2] + mu * (p1[2] - p0[2])
    };
}

inline std::array<float, 3> compute_normal(const std::array<float, 3>& p0, const std::array<float, 3>& p1,
    const std::array<float, 3>& p2) {
    const std::array<float, 3> u{
        p1[0] - p0[0],
        p1[1] - p0[1],
        p1[2] - p0[2]
    };
    const std::array<float, 3> v{
        p2[0] - p0[0],
        p2[1] - p0[1],
        p2[2] - p0[2]
    };

    std::array<float, 3> normal{
        v[1] * u[2] - v[2] * u[1],
        v[2] * u[0] - v[0] * u[2],
        v[0] * u[1] - v[1] * u[0]
    };

    const float length_sq = normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2];
    if (length_sq <= 1e-12f) {
        return std::array<float, 3>{0.0f, 0.0f, 0.0f};
    }
    const float inv_length = 1.0f / std::sqrt(length_sq);
    normal[0] *= inv_length;
    normal[1] *= inv_length;
    normal[2] *= inv_length;
    return normal;
}

} // namespace detail

template <typename DensitySampler, typename MaterialSampler>
[[nodiscard]] mesh_result marching_cubes(chunk_extent extent, DensitySampler&& density_sampler,
    MaterialSampler&& material_sampler, const marching_cubes_config& config = {}) {
    mesh_result result;
    const std::size_t approximate_cells = static_cast<std::size_t>(extent.volume());
    result.vertices.reserve(approximate_cells * 3);
    result.indices.reserve(approximate_cells * 3);

    std::array<std::array<float, 3>, 12> edge_vertices{};
    const auto& edge_table = detail::mc_edge_table;
    const auto& triangle_table = detail::mc_triangle_table;

    for (std::size_t z = 0; z < extent.z; ++z) {
        for (std::size_t y = 0; y < extent.y; ++y) {
            for (std::size_t x = 0; x < extent.x; ++x) {
                std::array<float, 8> corner_values{};
                std::array<std::array<float, 3>, 8> corner_positions{};

                for (int corner = 0; corner < 8; ++corner) {
                    const auto& offset = detail::cube_corners[corner];
                    const std::size_t sample_x = x + static_cast<std::size_t>(offset[0]);
                    const std::size_t sample_y = y + static_cast<std::size_t>(offset[1]);
                    const std::size_t sample_z = z + static_cast<std::size_t>(offset[2]);
                    corner_values[corner] = static_cast<float>(density_sampler(sample_x, sample_y, sample_z));
                    corner_positions[corner] = std::array<float, 3>{
                        static_cast<float>(x + offset[0]),
                        static_cast<float>(y + offset[1]),
                        static_cast<float>(z + offset[2])
                    };
                }

                int cube_index = 0;
                for (int corner = 0; corner < 8; ++corner) {
                    if (corner_values[corner] < config.iso_value) {
                        cube_index |= (1 << corner);
                    }
                }

                if (edge_table[cube_index] == 0) {
                    continue;
                }

                for (int edge = 0; edge < 12; ++edge) {
                    if ((edge_table[cube_index] & (1 << edge)) == 0) {
                        continue;
                    }
                    const auto connection = detail::edge_connection[static_cast<std::size_t>(edge)];
                    edge_vertices[edge] = detail::interpolate_vertex(
                        corner_positions[connection[0]],
                        corner_positions[connection[1]],
                        corner_values[connection[0]],
                        corner_values[connection[1]],
                        config.iso_value);
                }

                const voxel_id material = material_sampler(x, y, z);
                for (int tri = 0; triangle_table[cube_index][tri] != -1; tri += 3) {
                    const int a0 = triangle_table[cube_index][tri];
                    const int a1 = triangle_table[cube_index][tri + 1];
                    const int a2 = triangle_table[cube_index][tri + 2];

                    const auto& p0 = edge_vertices[a0];
                    const auto& p1 = edge_vertices[a1];
                    const auto& p2 = edge_vertices[a2];
                    const auto normal = detail::compute_normal(p0, p2, p1);

                    const auto base_index = static_cast<std::uint32_t>(result.vertices.size());
                    result.vertices.push_back(vertex{p0, normal, {p0[0], p0[1]}, material});
                    result.vertices.push_back(vertex{p2, normal, {p2[0], p2[1]}, material});
                    result.vertices.push_back(vertex{p1, normal, {p1[0], p1[1]}, material});
                    result.indices.insert(result.indices.end(), {base_index, base_index + 1, base_index + 2});
                }
            }
        }
    }

    return result;
}

template <typename DensitySampler>
[[nodiscard]] mesh_result marching_cubes(chunk_extent extent, DensitySampler&& density_sampler,
    const marching_cubes_config& config = {}, voxel_id material = voxel_id{1}) {
    auto material_sampler = [material](std::size_t, std::size_t, std::size_t) {
        return material;
    };
    return marching_cubes(extent, std::forward<DensitySampler>(density_sampler), material_sampler, config);
}

template <typename IsSolid>
[[nodiscard]] mesh_result marching_cubes_from_chunk(const chunk_storage& chunk, IsSolid&& is_solid,
    const chunk_neighbors& neighbors, const marching_cubes_config& config = {}) {
    const auto voxels = chunk.voxels();
    const auto extent = chunk.extent();
    const auto neighbor_views = detail::load_neighbor_views(neighbors);

    auto sample_voxel = [&](std::ptrdiff_t x, std::ptrdiff_t y, std::ptrdiff_t z) -> std::optional<voxel_id> {
        if (x >= 0 && x < static_cast<std::ptrdiff_t>(extent.x) && y >= 0 && y < static_cast<std::ptrdiff_t>(extent.y)
            && z >= 0 && z < static_cast<std::ptrdiff_t>(extent.z)) {
            return voxels(static_cast<std::size_t>(x), static_cast<std::size_t>(y), static_cast<std::size_t>(z));
        }

        std::array<std::ptrdiff_t, 3> coord{x, y, z};
        const detail::neighbor_view* view = nullptr;
        if (!detail::remap_to_neighbor_coords(extent, coord, neighbor_views, view)) {
            return std::nullopt;
        }
        return view->voxels(static_cast<std::size_t>(coord[0]), static_cast<std::size_t>(coord[1]),
            static_cast<std::size_t>(coord[2]));
    };

    auto density_sampler = [&](std::size_t vx, std::size_t vy, std::size_t vz) -> float {
        const auto sample = sample_voxel(static_cast<std::ptrdiff_t>(vx), static_cast<std::ptrdiff_t>(vy),
            static_cast<std::ptrdiff_t>(vz));
        if (!sample) {
            return 1.0f;
        }
        return is_solid(*sample) ? 0.0f : 1.0f;
    };

    auto material_sampler = [&](std::size_t x, std::size_t y, std::size_t z) {
        return voxels(x, y, z);
    };

    return marching_cubes(extent, density_sampler, material_sampler, config);
}

inline mesh_result marching_cubes_from_chunk(const chunk_storage& chunk, const marching_cubes_config& config = {}) {
    return marching_cubes_from_chunk(chunk, [](voxel_id id) { return id != voxel_id{}; }, chunk_neighbors{}, config);
}

} // namespace almond::voxel::meshing
// end: almond_voxel/meshing/marching_cubes.hpp

// begin: almond_voxel/serialization/region_io.hpp


#include <cstddef>
#include <cstdint>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <optional>
#include <span>
#include <stdexcept>
#include <string_view>
#include <utility>
#include <vector>

namespace almond::voxel::serialization {

struct chunk_header {
    char magic[4]{'A', 'V', 'C', 'K'};
    std::uint32_t version{1};
    std::uint32_t extent[3]{1, 1, 1};
};

struct region_blob {
    region_key key{};
    std::vector<std::byte> payload;
};

inline void append_bytes(std::vector<std::byte>& buffer, const void* data, std::size_t size) {
    const auto* bytes = static_cast<const std::byte*>(data);
    buffer.insert(buffer.end(), bytes, bytes + size);
}

inline std::vector<std::byte> serialize_chunk(const chunk_storage& chunk) {
    const auto extent = chunk.extent();
    const auto voxel_data = chunk.voxels();
    const auto sky_data = chunk.skylight();
    const auto block_data = chunk.blocklight();
    const auto meta_data = chunk.metadata();

    chunk_header header{};
    header.extent[0] = extent.x;
    header.extent[1] = extent.y;
    header.extent[2] = extent.z;

    std::vector<std::byte> buffer;
    buffer.reserve(sizeof(chunk_header) + extent.volume() * (sizeof(voxel_id) + 3));
    append_bytes(buffer, &header, sizeof(chunk_header));

    const auto copy_span = [&buffer](auto span) {
        using value_type = typename decltype(span)::value_type;
        append_bytes(buffer, span.data(), span.size() * sizeof(value_type));
    };

    copy_span(voxel_data.linear());
    copy_span(sky_data.linear());
    copy_span(block_data.linear());
    copy_span(meta_data.linear());

    return buffer;
}

inline chunk_storage deserialize_chunk(std::span<const std::byte> bytes) {
    if (bytes.size() < sizeof(chunk_header)) {
        throw std::runtime_error("chunk payload too small");
    }
    const auto* header = reinterpret_cast<const chunk_header*>(bytes.data());
    if (std::string_view(header->magic, 4) != std::string_view{"AVCK", 4}) {
        throw std::runtime_error("invalid chunk magic");
    }
    chunk_extent extent{header->extent[0], header->extent[1], header->extent[2]};
    const std::size_t expected = extent.volume();

    const std::size_t payload_size = sizeof(chunk_header) + expected * (sizeof(voxel_id) + 3);
    if (bytes.size() < payload_size) {
        throw std::runtime_error("chunk payload truncated");
    }

    chunk_storage chunk{extent};
    auto* ptr = bytes.data() + sizeof(chunk_header);

    auto copy_into = [&ptr, expected](auto view) {
        using value_type = typename decltype(view)::element_type;
        std::memcpy(view.linear().data(), ptr, expected * sizeof(value_type));
        ptr += expected * sizeof(value_type);
    };

    copy_into(chunk.voxels());
    copy_into(chunk.skylight());
    copy_into(chunk.blocklight());
    copy_into(chunk.metadata());
    chunk.mark_dirty(false);
    return chunk;
}

inline void serialize_chunk_to_stream(const chunk_storage& chunk, std::ostream& out) {
    auto payload = serialize_chunk(chunk);
    out.write(reinterpret_cast<const char*>(payload.data()), static_cast<std::streamsize>(payload.size()));
}

inline chunk_storage deserialize_chunk_from_stream(std::istream& in) {
    chunk_header header{};
    in.read(reinterpret_cast<char*>(&header), sizeof(header));
    if (!in) {
        throw std::runtime_error("unable to read chunk header");
    }
    if (std::string_view(header.magic, 4) != std::string_view{"AVCK", 4}) {
        throw std::runtime_error("invalid chunk magic");
    }
    chunk_extent extent{header.extent[0], header.extent[1], header.extent[2]};
    const std::size_t expected = extent.volume();
    std::vector<std::byte> payload;
    payload.resize(expected * (sizeof(voxel_id) + 3));
    in.read(reinterpret_cast<char*>(payload.data()), static_cast<std::streamsize>(payload.size()));
    if (!in) {
        throw std::runtime_error("unable to read chunk payload");
    }
    std::vector<std::byte> full;
    full.reserve(sizeof(chunk_header) + payload.size());
    append_bytes(full, &header, sizeof(header));
    full.insert(full.end(), payload.begin(), payload.end());
    return deserialize_chunk(full);
}

inline region_blob serialize_snapshot(const region_manager::region_snapshot& snapshot) {
    region_blob blob;
    blob.key = snapshot.key;
    if (snapshot.chunk) {
        blob.payload = serialize_chunk(*snapshot.chunk);
    }
    return blob;
}

template <typename Sink>
auto make_region_serializer(Sink&& sink) {
    return [sink = std::forward<Sink>(sink)](const region_manager::region_snapshot& snapshot) mutable {
        sink(serialize_snapshot(snapshot));
    };
}

template <typename Sink>
void dump_region(const region_manager& manager, Sink&& sink, bool include_clean = false) {
    auto&& callable = std::forward<Sink>(sink);
    for (const auto& snapshot : manager.snapshot_loaded(include_clean)) {
        callable(snapshot);
    }
}

inline auto file_sink(const std::filesystem::path& path) {
    return [path](const region_blob& blob) {
        std::filesystem::create_directories(path.parent_path());
        std::ofstream out(path, std::ios::binary | std::ios::app);
        if (!out) {
            throw std::runtime_error("failed to open region file");
        }
        out.write(reinterpret_cast<const char*>(&blob.key), sizeof(blob.key));
        const std::uint32_t size = static_cast<std::uint32_t>(blob.payload.size());
        out.write(reinterpret_cast<const char*>(&size), sizeof(size));
        out.write(reinterpret_cast<const char*>(blob.payload.data()), static_cast<std::streamsize>(blob.payload.size()));
    };
}

inline std::optional<region_blob> read_region_blob(std::istream& in) {
    region_blob blob;
    in.read(reinterpret_cast<char*>(&blob.key), sizeof(blob.key));
    if (!in) {
        return std::nullopt;
    }
    std::uint32_t size = 0;
    in.read(reinterpret_cast<char*>(&size), sizeof(size));
    if (!in) {
        return std::nullopt;
    }
    blob.payload.resize(size);
    in.read(reinterpret_cast<char*>(blob.payload.data()), static_cast<std::streamsize>(size));
    if (!in) {
        return std::nullopt;
    }
    return blob;
}

inline void ingest_blob(region_manager& manager, const region_blob& blob) {
    chunk_storage chunk = deserialize_chunk(blob.payload);
    auto& target = manager.assure(blob.key);
    target.assign_voxels(chunk.voxels().linear());
    auto sky = target.skylight();
    auto block = target.blocklight();
    auto meta = target.metadata();
    std::memcpy(sky.linear().data(), chunk.skylight().linear().data(), sky.linear().size_bytes());
    std::memcpy(block.linear().data(), chunk.blocklight().linear().data(), block.linear().size_bytes());
    std::memcpy(meta.linear().data(), chunk.metadata().linear().data(), meta.linear().size_bytes());
    target.mark_dirty(false);
}

} // namespace almond::voxel::serialization
// end: almond_voxel/serialization/region_io.hpp

// begin: almond_voxel/terrain/classic.hpp


#include <cmath>
#include <cstdint>
#include <vector>

namespace almond::voxel::terrain {

struct classic_config {
    double base_height{48.0};
    double elevation_amplitude{32.0};
    double detail_amplitude{8.0};
    double base_frequency{0.008};
    double detail_frequency{0.032};
    voxel_id surface_voxel{voxel_id{1}};
    voxel_id filler_voxel{voxel_id{1}};
    voxel_id subsurface_voxel{voxel_id{1}};
    voxel_id bedrock_voxel{voxel_id{1}};
    std::uint32_t bedrock_layers{2};
    std::uint32_t surface_depth{4};
};

class classic_heightfield {
public:
    explicit classic_heightfield(chunk_extent extent = cubic_extent(32), classic_config config = {}, std::uint64_t seed = 1337);

    [[nodiscard]] chunk_extent extent() const noexcept { return extent_; }

    [[nodiscard]] chunk_storage operator()(const region_key& key) const;
    [[nodiscard]] double sample_height(double world_x, double world_y) const;
    [[nodiscard]] const classic_config& config() const noexcept { return config_; }

private:
    chunk_extent extent_{};
    classic_config config_{};
    generation::value_noise base_noise_;
    generation::value_noise detail_noise_;
};

inline classic_heightfield::classic_heightfield(chunk_extent extent, classic_config config, std::uint64_t seed)
    : extent_{extent}
    , config_{config}
    , base_noise_{seed, config.base_frequency, 5, 0.55}
    , detail_noise_{seed ^ 0xA5A5A5A5u, config.detail_frequency, 3, 0.6} {
}

inline chunk_storage classic_heightfield::operator()(const region_key& key) const {
    chunk_storage chunk{extent_};
    auto voxels = chunk.voxels();

    const std::uint32_t size_x = extent_.x;
    const std::uint32_t size_y = extent_.y;
    const std::uint32_t size_z = extent_.z;

    const double base_world_x = static_cast<double>(key.x) * static_cast<double>(size_x);
    const double base_world_y = static_cast<double>(key.y) * static_cast<double>(size_y);
    const std::int64_t base_world_z = static_cast<std::int64_t>(key.z) * static_cast<std::int64_t>(size_z);

    std::vector<std::int32_t> column_heights(static_cast<std::size_t>(size_x) * static_cast<std::size_t>(size_y));
    for (std::uint32_t y = 0; y < size_y; ++y) {
        const double world_y = base_world_y + static_cast<double>(y);
        const std::size_t row_offset = static_cast<std::size_t>(y) * static_cast<std::size_t>(size_x);
        for (std::uint32_t x = 0; x < size_x; ++x) {
            const double world_x = base_world_x + static_cast<double>(x);
            const double height = sample_height(world_x, world_y);
            column_heights[row_offset + x] = static_cast<std::int32_t>(std::floor(height));
        }
    }

    const std::uint32_t filler_depth = config_.surface_depth;
    const std::int64_t bedrock_limit = static_cast<std::int64_t>(config_.bedrock_layers);

    for (std::uint32_t z = 0; z < size_z; ++z) {
        const std::int64_t world_z = base_world_z + static_cast<std::int64_t>(z);
        for (std::uint32_t y = 0; y < size_y; ++y) {
            const std::size_t row_offset = static_cast<std::size_t>(y) * static_cast<std::size_t>(size_x);
            for (std::uint32_t x = 0; x < size_x; ++x) {
                const std::int32_t column_height = column_heights[row_offset + x];
                auto& voxel = voxels(x, y, z);

                if (world_z < bedrock_limit) {
                    voxel = config_.bedrock_voxel;
                    continue;
                }

                if (world_z > column_height) {
                    voxel = voxel_id{};
                    continue;
                }

                const std::int32_t depth = column_height - static_cast<std::int32_t>(world_z);
                if (depth == 0) {
                    voxel = config_.surface_voxel;
                } else if (depth <= static_cast<std::int32_t>(filler_depth)) {
                    voxel = config_.filler_voxel;
                } else {
                    voxel = config_.subsurface_voxel;
                }
            }
        }
    }

    return chunk;
}

inline double classic_heightfield::sample_height(double world_x, double world_y) const {
    const double base = base_noise_.sample(world_x, world_y) * config_.elevation_amplitude;
    const double detail = detail_noise_.sample(world_x, world_y) * config_.detail_amplitude;
    return config_.base_height + base + detail;
}

} // namespace almond::voxel::terrain
// end: almond_voxel/terrain/classic.hpp

// begin: almond_voxel/version.hpp

namespace almond_voxel {

inline constexpr int major_version = 0;
inline constexpr int minor_version = 1;
inline constexpr int patch_version = 0;

inline constexpr const char* version_string() noexcept {
    return "0.1.0";
}

} // namespace almond_voxel
// end: almond_voxel/version.hpp

#endif // ALMOND_VOXEL_SINGLE_HPP
